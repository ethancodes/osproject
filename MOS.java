/**
 *  This class is the root class for the MOS.
 *
 *  @author Ken Schulz & Ethan Georgi
 *  @version 9.12.1998, 12.06.1998
 */
import java.io.*;

public class MOS
{
   int mosClock;
   Drisk drisk;
   Memory memory;
   Queue TerminateQ;
   Queue ReadyQ;
   Queue LoadQ;
   Queue MemoryQ;
   PCB p;
   BufferPool bufPool;
   CPU cpu;
   Channel1 Ch1;
   Channel2 Ch2;
   Channel3 Ch3;

/**
 * Default Constructor
 *
 */
   public MOS()
   {
         // Delete any existing tracing and output files
         // that may be generated by the OS
      File trace = new File("trace.mos");
      File printer = new File("printer.mos");
      trace.delete();
      printer.delete();

      mosClock = 0;
      drisk = new Drisk();
      memory = new Memory();
      TerminateQ = new Queue();
      ReadyQ = new Queue();
      LoadQ = new Queue();
      MemoryQ = new Queue();
      p = null;
      bufPool = new BufferPool();
      cpu = new CPU(memory, drisk, this, p);
      Ch1 = new Channel1(bufPool, cpu);
      Ch2 = new Channel2(bufPool, cpu);
      Ch3 = new Channel3(drisk, memory, this, cpu, bufPool, ReadyQ, TerminateQ);

      Trace.writeln("MOS ver. 0.12.1998a"
                  + " - Written by Ethan Georgi and Ken Schulz");
      Ch1.setBusy();
      while (Ch1.isBusy() || Ch2.isBusy() || Ch3.isBusy() || !ReadyQ.isEmpty())
      {
         tick();
      }
      Trace.writeln("MOS Complete - No more jobs on ready queue "
                  + "and OS is not doing anything!");
   }  // END - Constructor

/**
 * Runs the OS, one clock cycle
 * Slave Mode. Invoked only if there is a process int the ReadyQ
 * Simulation Mode. generates TI and IOI
 * Master Mode calculated each clock cycle
 * Interrupts are handled and loads a process into the current PCB
 * if one does not already exist and there is one available in the
 * ready queue.
 */
   public void tick()
   {
      Trace.writeln("MOS Clock Cycle# " + mosClock);

         // Slave Mode
      Trace.write("* * * Slave Mode: ");
      if (!ReadyQ.isEmpty())
      {
         Trace.write("Ready Queue Contents (");
         for (int i = 0; i < ReadyQ.getSize(); i++)
         {
            PCB rqpcb = (PCB)ReadyQ.getElementAt(i);
            Trace.write("ID#" + rqpcb.getJobID());
            if (ReadyQ.getSize() > i + 1) { Trace.write(", "); }
         }
         Trace.writeln(")");

            // Load New PCB
         p = (PCB)ReadyQ.dequeue();

            // Trace PCB Info
         Trace.writeln("JOB_ID# " + p.getJobID()
                     + ": IC(" + Integer.toString(p.getIC())
                     + "), RealAddr("
                     + Integer.toString(p.virtualToPhysical(p.getIC()))
                     + "), IR(" + p.getIR() + ")");

            // Send PCB to CPU
         cpu.setPCB(p);
         cpu.fetch();
         cpu.execute();

            // Trace PCB Info
         Trace.writeln("JOB_ID# " + p.getJobID()
                     + ": IC(" + Integer.toString(p.getIC())
                     + "), RealAddr("
                     + Integer.toString(p.virtualToPhysical(p.getIC()))
                     + "), IR(" + p.getIR() + ")");

         if (p != null)
         {
           Trace.writeln("IC(" + Integer.toString(p.getIC()) + ")");
         }
      }
      else
      {
         Trace.writeln("NO JOB ON READY QUEUE");
      }

         // Simulation Mode
      Trace.writeln("* * * Simulation Mode * * *");
      incClocks();   // Increments Clocks for Channels (Set IOI)

         // Display Channel Busy Status
      Trace.write("CH1(");
         if (Ch1.isBusy()) { Trace.write("busy, " + Ch1.getTimer() + "), "); }
         else { Trace.write("idle), "); }
      Trace.write("CH2(");
         if (Ch2.isBusy()) { Trace.write("busy, " + Ch2.getTimer() + "), "); }
         else { Trace.write("idle), "); }
      Trace.write("CH3(");
         if (Ch3.isBusy()) { Trace.writeln("busy, " + Ch3.getTimer() + ")"); }
         else { Trace.writeln("idle)"); }

         // Set timer interruptes for current process, if there was one!
      if (p != null)
      {
         Trace.write("System Timer(" + mosClock
                   + "), Time Slice(" + p.getTimeSlice()
                   + "), Total Time(" + p.getTimer() + ")");
         if (p.getTimeSlice() == 15)
         {
            cpu.setTI(1);
            Trace.write("JOB_ID# " + p.getJobID() + ", TI(1), TimeSlice up");
         }
         if (p.getTimer() == p.getTimeLimit())
         {
            cpu.setTI(2);
            Trace.write("JOB_ID# " + p.getJobID() + ", TI(2), Total Time up");
         }
         Trace.writeln("");   // Print a CR
      }

         // Master mode
      Trace.writeln("* * * MASTER MODE * * *");
      Trace.writeln("Value of Interrupts: PI(" + cpu.getPI()
                  + "), SI(" + cpu.getSI()
                  + "), TI(" + cpu.getTI()
                  + "), IOI(" + cpu.getIOI() + ")");

         // Handle Messed up case of SI and TI interrupts set at same time
      if ((cpu.getSI() > 0) && (cpu.getTI() > 0))
      {
         if ((cpu.getTI() == 1) || (cpu.getSI() > 1))
         {  // When timeslice is up SI takes priority
            handleSI();
            cpu.setTI(-cpu.getTI());
         }
         else
         {
            handleTI();
            cpu.setSI(0);
         }
      }
      else  // Handle Interrupts one by one
      {
         handleSI();
         handleTI();
      }
         // Continue with non conflict interrupts
      handlePI();
      handleIOI();
      handleMemQ();

         // If necessary, kick appropiate channel
      if (!TerminateQ.isEmpty() && !Ch3.isBusy())
      {
         Ch3.interruptRoutine();
      }
      if (!bufPool.isEMEmpty() && !Ch1.isBusy())
      {
         Ch1.setBusy();
      }

         // Place current PCB back on Ready Queue (If there is any)
      if (p != null)
      {
         ReadyQ.push(p);
         p = null;
      }
   }  // END - Constructor

  /**
   *  Increments all the clocks on the channels like magic.
   */
  public void incClocks()
  {
    if (Ch1.isBusy()) { Ch1.incClock(); }
    if (Ch2.isBusy()) { Ch2.incClock(); }
    if (Ch3.isBusy()) { Ch3.incClock(); }
    mosClock++;
  }

  /**
   *  Handles any Supervisor Interrupts that were set during slave mode.
   */
  public void handleSI()
  {
    if (cpu.getSI() > 0) {
      Trace.write("Handling System Interrupt (" + cpu.getSI() + "), ");
    }
    switch (cpu.getSI())
    {
      case 1 : //input needed. GD
        Trace.writeln("PCB --> Channel3 Queue (GD Called)");
        p.storeRegisters(cpu.getR(), cpu.getIR(), cpu.getC(), cpu.getIC());
        p.resetTimeSlice();
        Ch3.addToCh3Q(p);
        p = null;
        cpu.setSI(0);
        if (!Ch3.isBusy()) { Ch3.interruptRoutine(); }
        break;
      case 2 : //output needed. PD
        Trace.writeln("PCB --> Channel3 Queue (PD Called)");
        p.storeRegisters(cpu.getR(), cpu.getIR(), cpu.getC(), cpu.getIC());
        p.resetTimeSlice();
        Ch3.addToCh3Q(p);
        p = null;
        cpu.setSI(0);
        if (!Ch3.isBusy()) { Ch3.interruptRoutine(); }
        break;
      case 3 : //normal termination
        Trace.writeln("PCB --> Terminate Queue");
        p.storeRegisters(cpu.getR(), cpu.getIR(), cpu.getC(), cpu.getIC());
        p.eojMessage[0] = "JOB" + p.getJobID() + " has terminated normally.";
        TerminateQ.enqueue(p);
        p = null;
        cpu.setSI(0);
        break;
    }
  }

  /**
   *  Takes care of any Program Interrupts that occured during slave mode
   */
  public void handlePI()
  {
    if (cpu.getPI() > 0) {
      Trace.write("Handling Program Interrupt (" + cpu.getPI() + "), ");
    }
    switch (cpu.getPI())
    {
      case 1 : //operation error... twit user
        Trace.writeln("PCB --> Terminate Queue (Operation Error "
                     + cpu.getIR() + ")");
        p.storeRegisters(cpu.getR(), cpu.getIR(), cpu.getC(), cpu.getIC());
        p.eojMessage[0] = "JOB" + p.getJobID() + " had an operation error.";
        TerminateQ.enqueue(p);
        p = null;
        cpu.setPI(0);
        break;
      case 2 : //operand error...
        Trace.writeln("PCB --> Terminate Queue (Operand Error "
                     + cpu.getIR() + ")");
        p.storeRegisters(cpu.getR(), cpu.getIR(), cpu.getC(), cpu.getIC());
        p.eojMessage[0] = "JOB" + p.getJobID() + " had an operand error.";
        TerminateQ.enqueue(p);
        p = null;
        cpu.setPI(0);
        break;
      case 3 : //memory violation
        Trace.writeln("PCB --> Terminate Queue (Memory Violation "
                     + cpu.getIR() + ")");
        p.storeRegisters(cpu.getR(), cpu.getIR(), cpu.getC(), cpu.getIC());
        p.eojMessage[0] = "JOB" + p.getJobID() + " violated memory.";
        TerminateQ.enqueue(p);
        p = null;
        cpu.setPI(0);
        break;
    }
  }

/**
 *  Handles any interrupts that have been generated by Channel 1, 2, or 3
 */
  public void handleIOI()
  {
    boolean outputSpool = false;
    while (cpu.getIOI() > 0)
    {
      if ((cpu.getIOI() % 2) != 0)
      {
        Ch1.cleanUp();
      }
      else if (cpu.getIOI() >= 4)
      {
        outputSpool = (Ch3.getTaskFlag() == 1);
        Ch3.interruptRoutine();
      }
      else
      {
        Ch2.cleanUp();
      }
    } //end ov zee while loop
    if (!Ch3.isBusy()) { Ch3.interruptRoutine(); }
    if (outputSpool && !Ch2.isBusy()) { Ch2.setBusy(); }
  }

/**
 *  Handles any interrupts that have been generated by the program time
 */
   public void handleTI()
   {
      if (cpu.getTI() > 0) {
         Trace.write("Handling Timer Interrupt (" + cpu.getTI() + "), ");
      }

      switch (cpu.getTI()) {
         case 1:  // TI = 1, Time Slice up
            Trace.writeln("PCB --> ReadyQ (TimeSlice Up)");
            ReadyQ.enqueue(p);
            p = null;
            break;
         case 2:  // TI = 2, Total Time up
            Trace.writeln("PCB --> TerminateQ (JOB" + p.getJobID()
                        + " ran out of time)");
            p.eojMessage[0] = "JOB" + p.getJobID() + " ran out of time.";
            TerminateQ.enqueue(p);
            p = null;
            break;
         case 3: // TI = 3, Both TImeSlice and Total Time are up!
            Trace.writeln("PCB --> TerminateQ (JOB" + p.getJobID()
                        + " ran out of time)");
            p.eojMessage[0] = "JOB" + p.getJobID() + " ran out of time.";
            TerminateQ.enqueue(p);
            p = null;
            break;
      }  // END - suitch (cpu.getTI())
      cpu.setTI(-cpu.getTI());
   }

/**
 * Adds a process to the memory queue to be granted additional memory.
 * Request is allowed one page at a time, therefore priority is FIFO
 *
 * @param addPCB is a reference to the PCB that will be added to the
 *        memory wait queue
 */
   public void addToMemQ(PCB addPCB)
   {
      MemoryQ.enqueue(addPCB);
      p = null;
   }

/**
 * Handles the memory queue, current implementation only allocates
 * memory needed. Anotherwords we are screwed if there is not enough
 * main memory to swap somethin in.
 *
 * Process only comes here if it did an SR or GD instruction on a piece
 * of memory which hasn't been allocated.
 *
 * No parameters
 */
   public void handleMemQ()
   {
         // If there is availabe main memory then load / allocate the page
      if (!memory.isFull() && !MemoryQ.isEmpty())
      {
            // Get available main memory block and Allocate for use
         int availMemBlock = memory.allocate();

            // Get PCB info to load a page into main mem or allocate anew
         PCB pcb = (PCB)MemoryQ.dequeue();
         String operator = pcb.getIR().substring(0, 2);
         int vAddress = Integer.parseInt(pcb.getIR().substring(2, 4));

         pcb.pageTable[vAddress / 10] = availMemBlock;

            //must've come from Ch3
         if (pcb.getIR().substring(0, 2).equals("GD"))
         {
           Ch3.addToCh3Q(pcb);
         }
         else
         {
           pcb.setIC(pcb.getIC() - 1);
           ReadyQ.enqueue(pcb);
         }
         pcb = null;
      }
   }

/**
 * Main Method
 */
   public static void main(String[] arg)
   {
      new MOS();
   }

}  // END - class MOS